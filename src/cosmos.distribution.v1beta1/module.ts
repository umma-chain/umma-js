// Generated by Ignite ignite.com/cli

import { StdFee } from "@cosmjs/launchpad";
import { SigningStargateClient, DeliverTxResponse } from "@cosmjs/stargate";
import {
  EncodeObject, GeneratedType, OfflineSigner, Registry,
} from "@cosmjs/proto-signing";
import { msgTypes } from "./registry";
import { IgniteClient } from "../client";
import { MissingWalletError } from "../helpers";
import { Api } from "./rest";
import {
  MsgWithdrawValidatorCommission, MsgSetWithdrawAddress, MsgWithdrawDelegatorReward, MsgFundCommunityPool,
} from "./types/cosmos/distribution/v1beta1/tx";

import {
  Params as typeParams, ValidatorHistoricalRewards as typeValidatorHistoricalRewards, ValidatorCurrentRewards as typeValidatorCurrentRewards, ValidatorAccumulatedCommission as typeValidatorAccumulatedCommission, ValidatorOutstandingRewards as typeValidatorOutstandingRewards, ValidatorSlashEvent as typeValidatorSlashEvent, ValidatorSlashEvents as typeValidatorSlashEvents, FeePool as typeFeePool, CommunityPoolSpendProposal as typeCommunityPoolSpendProposal, DelegatorStartingInfo as typeDelegatorStartingInfo, DelegationDelegatorReward as typeDelegationDelegatorReward, CommunityPoolSpendProposalWithDeposit as typeCommunityPoolSpendProposalWithDeposit, DelegatorWithdrawInfo as typeDelegatorWithdrawInfo, ValidatorOutstandingRewardsRecord as typeValidatorOutstandingRewardsRecord, ValidatorAccumulatedCommissionRecord as typeValidatorAccumulatedCommissionRecord, ValidatorHistoricalRewardsRecord as typeValidatorHistoricalRewardsRecord, ValidatorCurrentRewardsRecord as typeValidatorCurrentRewardsRecord, DelegatorStartingInfoRecord as typeDelegatorStartingInfoRecord, ValidatorSlashEventRecord as typeValidatorSlashEventRecord,
} from "./types";

export {
  MsgWithdrawValidatorCommission, MsgSetWithdrawAddress, MsgWithdrawDelegatorReward, MsgFundCommunityPool,
};

type sendMsgWithdrawValidatorCommissionParams = {
  value: MsgWithdrawValidatorCommission,
  fee?: StdFee,
  memo?: string
};

type sendMsgSetWithdrawAddressParams = {
  value: MsgSetWithdrawAddress,
  fee?: StdFee,
  memo?: string
};

type sendMsgWithdrawDelegatorRewardParams = {
  value: MsgWithdrawDelegatorReward,
  fee?: StdFee,
  memo?: string
};

type sendMsgFundCommunityPoolParams = {
  value: MsgFundCommunityPool,
  fee?: StdFee,
  memo?: string
};

type msgWithdrawValidatorCommissionParams = {
  value: MsgWithdrawValidatorCommission,
};

type msgSetWithdrawAddressParams = {
  value: MsgSetWithdrawAddress,
};

type msgWithdrawDelegatorRewardParams = {
  value: MsgWithdrawDelegatorReward,
};

type msgFundCommunityPoolParams = {
  value: MsgFundCommunityPool,
};

export const registry = new Registry(msgTypes);

type Field = {
  name: string;
  type: unknown;
};
function getStructure(template) {
  const structure: { fields: Field[] } = { fields: [] };
  for (const [key, value] of Object.entries(template)) {
    const field = { name: key, type: typeof value };
    structure.fields.push(field);
  }
  return structure;
}
const defaultFee = {
  amount: [],
  gas: "200000",
};

interface TxClientOptions {
  addr: string
  prefix: string
  signer?: OfflineSigner
}

export const txClient = ({ signer, prefix, addr }: TxClientOptions = { addr: "http://localhost:26657", prefix: "cosmos" }) => ({

  async sendMsgWithdrawValidatorCommission({ value, fee, memo }: sendMsgWithdrawValidatorCommissionParams): Promise<DeliverTxResponse> {
    if (!signer) {
      throw new Error("TxClient:sendMsgWithdrawValidatorCommission: Unable to sign Tx. Signer is not present.");
    }
    try {
      const { address } = (await signer.getAccounts())[0];
      const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
      const msg = this.msgWithdrawValidatorCommission({ value: MsgWithdrawValidatorCommission.fromPartial(value) });
      return await signingClient.signAndBroadcast(address, [msg], fee || defaultFee, memo);
    } catch (e: any) {
      throw new Error(`TxClient:sendMsgWithdrawValidatorCommission: Could not broadcast Tx: ${e.message}`);
    }
  },

  async sendMsgSetWithdrawAddress({ value, fee, memo }: sendMsgSetWithdrawAddressParams): Promise<DeliverTxResponse> {
    if (!signer) {
      throw new Error("TxClient:sendMsgSetWithdrawAddress: Unable to sign Tx. Signer is not present.");
    }
    try {
      const { address } = (await signer.getAccounts())[0];
      const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
      const msg = this.msgSetWithdrawAddress({ value: MsgSetWithdrawAddress.fromPartial(value) });
      return await signingClient.signAndBroadcast(address, [msg], fee || defaultFee, memo);
    } catch (e: any) {
      throw new Error(`TxClient:sendMsgSetWithdrawAddress: Could not broadcast Tx: ${e.message}`);
    }
  },

  async sendMsgWithdrawDelegatorReward({ value, fee, memo }: sendMsgWithdrawDelegatorRewardParams): Promise<DeliverTxResponse> {
    if (!signer) {
      throw new Error("TxClient:sendMsgWithdrawDelegatorReward: Unable to sign Tx. Signer is not present.");
    }
    try {
      const { address } = (await signer.getAccounts())[0];
      const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
      const msg = this.msgWithdrawDelegatorReward({ value: MsgWithdrawDelegatorReward.fromPartial(value) });
      return await signingClient.signAndBroadcast(address, [msg], fee || defaultFee, memo);
    } catch (e: any) {
      throw new Error(`TxClient:sendMsgWithdrawDelegatorReward: Could not broadcast Tx: ${e.message}`);
    }
  },

  async sendMsgFundCommunityPool({ value, fee, memo }: sendMsgFundCommunityPoolParams): Promise<DeliverTxResponse> {
    if (!signer) {
      throw new Error("TxClient:sendMsgFundCommunityPool: Unable to sign Tx. Signer is not present.");
    }
    try {
      const { address } = (await signer.getAccounts())[0];
      const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
      const msg = this.msgFundCommunityPool({ value: MsgFundCommunityPool.fromPartial(value) });
      return await signingClient.signAndBroadcast(address, [msg], fee || defaultFee, memo);
    } catch (e: any) {
      throw new Error(`TxClient:sendMsgFundCommunityPool: Could not broadcast Tx: ${e.message}`);
    }
  },

  msgWithdrawValidatorCommission({ value }: msgWithdrawValidatorCommissionParams): EncodeObject {
    try {
      return { typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission", value: MsgWithdrawValidatorCommission.fromPartial(value) };
    } catch (e: any) {
      throw new Error(`TxClient:MsgWithdrawValidatorCommission: Could not create message: ${e.message}`);
    }
  },

  msgSetWithdrawAddress({ value }: msgSetWithdrawAddressParams): EncodeObject {
    try {
      return { typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress", value: MsgSetWithdrawAddress.fromPartial(value) };
    } catch (e: any) {
      throw new Error(`TxClient:MsgSetWithdrawAddress: Could not create message: ${e.message}`);
    }
  },

  msgWithdrawDelegatorReward({ value }: msgWithdrawDelegatorRewardParams): EncodeObject {
    try {
      return { typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward", value: MsgWithdrawDelegatorReward.fromPartial(value) };
    } catch (e: any) {
      throw new Error(`TxClient:MsgWithdrawDelegatorReward: Could not create message: ${e.message}`);
    }
  },

  msgFundCommunityPool({ value }: msgFundCommunityPoolParams): EncodeObject {
    try {
      return { typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPool", value: MsgFundCommunityPool.fromPartial(value) };
    } catch (e: any) {
      throw new Error(`TxClient:MsgFundCommunityPool: Could not create message: ${e.message}`);
    }
  },

});

interface QueryClientOptions {
  addr: string
}

export const queryClient = ({ addr }: QueryClientOptions = { addr: "http://localhost:1317" }) => new Api({ baseURL: addr });

class SDKModule {
  public query: ReturnType<typeof queryClient>;

  public tx: ReturnType<typeof txClient>;

  public structure: Record<string, unknown>;

  public registry: Array<[string, GeneratedType]> = [];

  constructor(client: IgniteClient) {
    this.query = queryClient({ addr: client.env.apiURL });
    this.updateTX(client);
    this.structure = {
      Params: getStructure(typeParams.fromPartial({})),
      ValidatorHistoricalRewards: getStructure(typeValidatorHistoricalRewards.fromPartial({})),
      ValidatorCurrentRewards: getStructure(typeValidatorCurrentRewards.fromPartial({})),
      ValidatorAccumulatedCommission: getStructure(typeValidatorAccumulatedCommission.fromPartial({})),
      ValidatorOutstandingRewards: getStructure(typeValidatorOutstandingRewards.fromPartial({})),
      ValidatorSlashEvent: getStructure(typeValidatorSlashEvent.fromPartial({})),
      ValidatorSlashEvents: getStructure(typeValidatorSlashEvents.fromPartial({})),
      FeePool: getStructure(typeFeePool.fromPartial({})),
      CommunityPoolSpendProposal: getStructure(typeCommunityPoolSpendProposal.fromPartial({})),
      DelegatorStartingInfo: getStructure(typeDelegatorStartingInfo.fromPartial({})),
      DelegationDelegatorReward: getStructure(typeDelegationDelegatorReward.fromPartial({})),
      CommunityPoolSpendProposalWithDeposit: getStructure(typeCommunityPoolSpendProposalWithDeposit.fromPartial({})),
      DelegatorWithdrawInfo: getStructure(typeDelegatorWithdrawInfo.fromPartial({})),
      ValidatorOutstandingRewardsRecord: getStructure(typeValidatorOutstandingRewardsRecord.fromPartial({})),
      ValidatorAccumulatedCommissionRecord: getStructure(typeValidatorAccumulatedCommissionRecord.fromPartial({})),
      ValidatorHistoricalRewardsRecord: getStructure(typeValidatorHistoricalRewardsRecord.fromPartial({})),
      ValidatorCurrentRewardsRecord: getStructure(typeValidatorCurrentRewardsRecord.fromPartial({})),
      DelegatorStartingInfoRecord: getStructure(typeDelegatorStartingInfoRecord.fromPartial({})),
      ValidatorSlashEventRecord: getStructure(typeValidatorSlashEventRecord.fromPartial({})),

    };
    client.on("signer-changed", (signer) => {
		 this.updateTX(client);
    });
  }

  updateTX(client: IgniteClient) {
    const methods = txClient({
      signer: client.signer,
      addr: client.env.rpcURL,
      prefix: client.env.prefix ?? "cosmos",
    });

    this.tx = methods;
    for (const m in methods) {
      this.tx[m] = methods[m].bind(this.tx);
    }
  }
}

const Module = (test: IgniteClient) => ({
  module: {
    CosmosDistributionV1Beta1: new SDKModule(test),
  },
  registry: msgTypes,
});
export default Module;
